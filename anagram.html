<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Balloon Game</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800;900&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #00BCD4, #4DD0E1); /* Cyan Theme */
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-x: hidden; 
        }

        #app-container {
            width: 100%;
            max-width: 900px;
            background-color: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            padding: 30px;
            min-height: 600px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* --- DRAGGABLE BALL STYLES (Round Balloons) --- */
        .letter-ball {
            position: absolute; 
            width: 64px;
            height: 64px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            font-weight: 900;
            color: white;
            border-radius: 50%; /* Perfect Circle */
            cursor: grab;
            user-select: none;
            touch-action: none;
            /* 3D Balloon Effect */
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.4), transparent);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2), inset -2px -2px 6px rgba(0,0,0,0.2);
            transition: transform 0.1s, box-shadow 0.1s;
            z-index: 10;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.2);
        }

        .letter-ball:active {
            cursor: grabbing;
        }
        
        .dragging {
            z-index: 1000 !important;
            transform: scale(1.2);
            box-shadow: 0 15px 30px rgba(0,0,0,0.3);
        }

        /* --- SLOT STYLES --- */
        #slots-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 40px;
            padding: 30px 10px;
            min-height: 100px;
            background-color: #f8fafc;
            border-radius: 16px;
            border: 2px dashed #cbd5e1;
        }

        .slot {
            width: 64px;
            height: 64px;
            border: 3px solid #e2e8f0;
            border-radius: 50%; /* Round slots */
            background-color: white;
            flex-shrink: 0;
            transition: all 0.2s;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }

        /* --- POOL STYLES --- */
        #letters-container {
            position: relative;
            min-height: 250px;
            border-top: 1px solid #f1f5f9;
            margin-top: auto; 
        }

        /* --- ANIMATIONS --- */
        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        .animate-pop {
            animation: pop 0.3s ease-out;
        }

        /* Setup Area Styling */
        textarea {
            @apply w-full p-4 border-2 border-slate-200 rounded-xl focus:outline-none focus:border-cyan-500 focus:ring-2 focus:ring-cyan-100 transition resize-y text-gray-700 font-bold font-mono;
            min-height: 200px; /* Made taller/wider */
        }
        
        .file-upload-btn {
            @apply w-full py-4 px-6 bg-slate-100 border-2 border-dashed border-slate-300 rounded-xl text-center cursor-pointer transition hover:bg-cyan-50 hover:border-cyan-400 hover:text-cyan-700 font-bold text-slate-500 flex flex-col items-center justify-center gap-2;
        }
        .file-upload-btn:active {
            @apply bg-slate-200 transform scale-95;
        }

        /* Buttons */
        .btn-action {
            @apply px-4 py-2 font-bold rounded-lg shadow-md transition transform active:scale-95;
        }
    </style>
</head>
<body>

    <div id="app-container">
        
        <div class="flex justify-between items-center mb-6">
            <button id="global-back-btn" class="text-slate-400 hover:text-cyan-600 font-bold flex items-center gap-2 transition">
                <span>‚Üê</span> <span id="back-label">Back to Tools</span>
            </button>
            <h1 class="text-2xl font-black text-slate-800 uppercase tracking-wide">The Balloon Game</h1>
            <div class="w-24"></div> </div>

        <div id="setup-panel" class="flex flex-col gap-6">
            <div class="bg-slate-50 p-6 rounded-2xl border border-slate-200">
                <h2 class="text-lg font-bold text-slate-700 mb-4">1. Create Vocabulary List</h2>
                
                <label class="block text-sm font-bold text-slate-600 mb-2">
                    Option A: Paste Words
                    <span class="block text-xs font-normal text-slate-400 mt-1">
                        Separate words with <strong class="text-slate-600">commas</strong> or place them on <strong class="text-slate-600">new lines</strong>.
                    </span>
                </label>
                
                <textarea id="vocab-paste" placeholder="Examples:&#10;APPLE, BANANA, CHERRY&#10;DOG&#10;CAT&#10;ELEPHANT"></textarea>

                <div class="flex items-center justify-between my-4">
                    <div class="h-px bg-slate-200 w-full"></div>
                    <span class="px-3 text-slate-400 font-bold text-sm">OR</span>
                    <div class="h-px bg-slate-200 w-full"></div>
                </div>

                <label class="block text-sm font-bold text-slate-600 mb-2">Option B: Upload CSV</label>
                <div class="file-upload-btn" onclick="document.getElementById('vocab-file').click()">
                    <span class="text-2xl">üìÇ</span>
                    <span id="file-name-display">Click to Select CSV File</span>
                    <input type="file" id="vocab-file" accept=".csv, .txt" class="hidden" onchange="updateFileName(this)">
                </div>
            </div>

            <button onclick="window.processVocabSource()" 
                    class="w-full py-4 bg-cyan-600 text-white font-black rounded-xl shadow-lg hover:bg-cyan-700 text-xl transition">
                START GAME üöÄ
            </button>
        </div>

        <div id="game-play-area" class="hidden flex-col flex-grow">
            
            <div class="flex justify-between items-center mb-4">
                <div class="text-sm font-bold text-slate-400">
                    Word <span id="word-counter" class="text-slate-800">1</span>
                </div>
                <div class="flex gap-3">
                    <button id="hint-button" onclick="window.giveHint()" class="btn-action bg-blue-100 text-blue-600 hover:bg-blue-200">
                        üí° Hint
                    </button>
                    <button id="skip-button" onclick="window.skipWord()" class="btn-action bg-red-100 text-red-600 hover:bg-red-200">
                        ‚è© Skip
                    </button>
                </div>
            </div>

            <div id="feedback-container" class="text-center min-h-[40px] mb-2">
                <p id="feedback-label" class="text-xl font-bold text-slate-600 transition-all">Pop the balloons into the slots!</p>
            </div>

            <div id="slots-container"></div>

            <div id="letters-container"></div>

            <div id="next-btn-container" class="absolute bottom-6 left-0 w-full flex justify-center pointer-events-none hidden z-50">
                <button onclick="window.newRound()" class="pointer-events-auto px-8 py-3 bg-green-500 text-white font-black text-lg rounded-full shadow-2xl hover:bg-green-600 hover:scale-105 transition transform animate-pop">
                    NEXT WORD ‚ûú
                </button>
            </div>

        </div>

    </div>

    <script>
        // --- CONSTANTS ---
        const BALL_SIZE = 64;
        const COLORS = [
            '#EF4444', '#F59E0B', '#10B981', '#3B82F6', '#6366F1', '#8B5CF6', '#EC4899', '#F43F5E'
        ];

        // --- STATE ---
        let vocabList = []; 
        let currentWordIndex = -1;
        const state = {
            currentWord: "",
            slots: [],
            balls: [],
            isDragging: false,
            activeBall: null,
            startX: 0, startY: 0, initialX: 0, initialY: 0,
            slotMap: new Map(), // slotId -> ballElement
            originalPosMap: new Map() // ballId -> {x, y}
        };

        // --- DOM ---
        const elements = {
            setupPanel: document.getElementById('setup-panel'),
            gamePlayArea: document.getElementById('game-play-area'),
            slotsContainer: document.getElementById('slots-container'),
            lettersContainer: document.getElementById('letters-container'),
            feedbackLabel: document.getElementById('feedback-label'),
            nextBtnContainer: document.getElementById('next-btn-container'),
            hintButton: document.getElementById('hint-button'),
            skipButton: document.getElementById('skip-button'),
            vocabFile: document.getElementById('vocab-file'),
            vocabPaste: document.getElementById('vocab-paste'),
            backBtn: document.getElementById('global-back-btn'),
            backLabel: document.getElementById('back-label'),
            wordCounter: document.getElementById('word-counter'),
            fileNameDisplay: document.getElementById('file-name-display')
        };

        // --- NAVIGATION ---
        elements.backBtn.addEventListener('click', () => {
            if (!elements.gamePlayArea.classList.contains('hidden')) {
                // If in game, go to Setup
                showSetup();
            } else {
                // If in setup, go to Index
                window.location.href = 'index.html';
            }
        });

        function showSetup() {
            elements.setupPanel.classList.remove('hidden');
            elements.gamePlayArea.classList.add('hidden');
            elements.backLabel.innerText = "Back to Tools";
        }

        function showGame() {
            elements.setupPanel.classList.add('hidden');
            elements.gamePlayArea.classList.remove('hidden');
            elements.backLabel.innerText = "Back to Setup";
        }
        
        function updateFileName(input) {
            if(input.files && input.files.length > 0) {
                elements.fileNameDisplay.innerText = "üìÑ " + input.files[0].name;
                elements.fileNameDisplay.classList.add('text-slate-800');
            }
        }

        // --- GAME LOGIC ---

        function processVocabSource() {
            const fileInput = elements.vocabFile;
            const pasteInput = elements.vocabPaste;
            
            if (fileInput.files && fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                reader.onload = (e) => parseAndStartGame(e.target.result);
                reader.readAsText(file);
            } else if (pasteInput.value.trim()) {
                parseAndStartGame(pasteInput.value);
            } else {
                alert("Please enter some words or upload a file!");
            }
        }

        function parseAndStartGame(content) {
            // Split by line first
            const lines = content.split(/\r?\n/);
            
            vocabList = lines
                .map(line => {
                    // CSV Logic: Take ONLY the first column (text before the first comma)
                    const firstCol = line.split(',')[0]; 
                    return firstCol.trim().toUpperCase();
                })
                .filter(w => w.length > 0 && /^[A-Z\s]+$/.test(w)); // Filter empties and non-letters

            // If only 1 line/no CSV structure found, try splitting by comma as a fallback for simple paste
            if (vocabList.length <= 1 && content.includes(',')) {
                vocabList = content.split(',')
                    .map(w => w.trim().toUpperCase())
                    .filter(w => w.length > 0 && /^[A-Z\s]+$/.test(w));
            }

            if (vocabList.length === 0) {
                alert("No valid words found. Check your file/text.");
                return;
            }
            
            vocabList.sort(() => Math.random() - 0.5);
            currentWordIndex = -1;
            showGame();
            newRound();
        }

        function newRound() {
            if (vocabList.length === 0) return showSetup();
            
            currentWordIndex = (currentWordIndex + 1) % vocabList.length;
            renderRound(vocabList[currentWordIndex]);
            elements.wordCounter.innerText = (currentWordIndex + 1) + " / " + vocabList.length;
        }

        function renderRound(word) {
            // Reset
            state.slots = [];
            state.balls = [];
            state.slotMap.clear();
            state.originalPosMap.clear();
            elements.slotsContainer.innerHTML = '';
            elements.lettersContainer.innerHTML = '';
            elements.nextBtnContainer.classList.add('hidden');
            elements.feedbackLabel.innerText = "Pop the balloons into the slots!";
            elements.feedbackLabel.className = "text-xl font-bold text-slate-600";
            
            state.currentWord = word;
            
            // Buttons
            elements.hintButton.disabled = false;
            elements.skipButton.disabled = false;

            // Scramble
            let chars = Array.from(word.replace(/\s/g, '')); // remove spaces for logic
            // Simple visual scramble
            let displayChars = [...chars].sort(() => Math.random() - 0.5);

            // Layout
            const containerWidth = elements.gamePlayArea.clientWidth - 40; 
            const itemWidth = BALL_SIZE + 10;
            const itemsPerRow = Math.floor(containerWidth / itemWidth);
            const numRows = Math.ceil(displayChars.length / itemsPerRow);
            const gap = (containerWidth - (itemsPerRow * itemWidth)) / 2;

            // 1. Create Slots
            let slotId = 0;
            Array.from(word).forEach(char => {
                if(char === ' ') {
                    // Visual separator for space
                    const space = document.createElement('div');
                    space.style.width = "20px";
                    elements.slotsContainer.appendChild(space);
                } else {
                    const slot = document.createElement('div');
                    slot.className = 'slot';
                    slot.dataset.target = char;
                    slot.dataset.id = slotId++;
                    elements.slotsContainer.appendChild(slot);
                    state.slots.push(slot);
                }
            });

            // 2. Create Balls
            displayChars.forEach((char, i) => {
                const ball = document.createElement('div');
                ball.className = 'letter-ball';
                ball.textContent = char;
                ball.dataset.char = char;
                ball.dataset.id = `ball-${i}`;
                
                // Assign random color
                const color = COLORS[i % COLORS.length];
                ball.style.backgroundColor = color;

                // Position
                const row = Math.floor(i / itemsPerRow);
                const col = i % itemsPerRow;
                
                // Add some randomness to position to feel "organic"
                const randX = (Math.random() * 10) - 5;
                const randY = (Math.random() * 10) - 5;

                const x = gap + (col * itemWidth) + randX;
                const y = 20 + (row * itemWidth) + randY;

                ball.style.left = `${x}px`;
                ball.style.top = `${y}px`;

                state.originalPosMap.set(ball.dataset.id, {x, y});

                // Events
                ball.addEventListener('mousedown', startDrag);
                ball.addEventListener('touchstart', startDrag);

                elements.lettersContainer.appendChild(ball);
                state.balls.push(ball);
            });
            
            elements.lettersContainer.style.height = (numRows * itemWidth + 50) + "px";
        }

        // --- DRAG AND DROP ---
        function getCoords(e) {
            if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }

        function startDrag(e) {
            e.preventDefault();
            const ball = e.currentTarget;
            if(ball.classList.contains('locked')) return; // Prevent moving locked balls

            const coords = getCoords(e);
            
            state.isDragging = true;
            state.activeBall = ball;
            
            // If dragging from a slot, free the slot
            if (ball.dataset.slotId) {
                state.slotMap.delete(ball.dataset.slotId);
                delete ball.dataset.slotId;
            }

            const rect = ball.getBoundingClientRect();
            state.startX = coords.x;
            state.startY = coords.y;
            state.initialX = rect.left;
            state.initialY = rect.top;

            ball.classList.add('dragging');

            document.addEventListener('mousemove', duringDrag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', duringDrag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function duringDrag(e) {
            if (!state.isDragging) return;
            const coords = getCoords(e);
            const dx = coords.x - state.startX;
            const dy = coords.y - state.startY;
            
            // Must convert to relative coords inside container
            const containerRect = elements.lettersContainer.getBoundingClientRect();
            
            state.activeBall.style.left = (state.initialX + dx - containerRect.left) + "px";
            state.activeBall.style.top = (state.initialY + dy - containerRect.top) + "px";
            
            if (e.touches) e.preventDefault();
        }

        function endDrag(e) {
            if (!state.isDragging) return;
            
            const ball = state.activeBall;
            const ballRect = ball.getBoundingClientRect();
            const ballCenterX = ballRect.left + ballRect.width/2;
            const ballCenterY = ballRect.top + ballRect.height/2;

            let snapped = false;

            // Check slots
            const containerRect = elements.lettersContainer.getBoundingClientRect();

            // Iterate slots to find nearest
            for (const slot of state.slots) {
                const slotRect = slot.getBoundingClientRect();
                const slotCenterX = slotRect.left + slotRect.width/2;
                const slotCenterY = slotRect.top + slotRect.height/2;
                
                const dist = Math.hypot(ballCenterX - slotCenterX, ballCenterY - slotCenterY);

                if (dist < 50) {
                    // Check if slot is empty
                    if (!state.slotMap.has(slot.dataset.id)) {
                        // Snap
                        ball.style.left = (slotRect.left - containerRect.left) + "px";
                        ball.style.top = (slotRect.top - containerRect.top) + "px";
                        
                        state.slotMap.set(slot.dataset.id, ball);
                        ball.dataset.slotId = slot.dataset.id;
                        
                        // Play pop animation
                        ball.classList.remove('animate-pop');
                        void ball.offsetWidth;
                        ball.classList.add('animate-pop');

                        snapped = true;
                        break;
                    }
                }
            }

            // Return to pool if not snapped
            if (!snapped) {
                const orig = state.originalPosMap.get(ball.dataset.id);
                ball.style.left = orig.x + "px";
                ball.style.top = orig.y + "px";
            }

            ball.classList.remove('dragging');
            state.isDragging = false;
            state.activeBall = null;

            document.removeEventListener('mousemove', duringDrag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', duringDrag);
            document.removeEventListener('touchend', endDrag);

            checkWin();
        }

        // --- WIN LOGIC ---
        function checkWin() {
            // 1. Are all slots full?
            if (state.slotMap.size < state.slots.length) return;

            // 2. Is it correct?
            let correct = true;
            let attempt = "";
            state.slots.forEach(slot => {
                const ball = state.slotMap.get(slot.dataset.id);
                if (ball.dataset.char !== slot.dataset.target) correct = false;
                attempt += ball.dataset.char;
            });

            if (correct) {
                elements.feedbackLabel.innerHTML = `üéâ Correct! <span class="text-cyan-600">${state.currentWord}</span>`;
                elements.nextBtnContainer.classList.remove('hidden');
                
                // Lock everything
                state.balls.forEach(b => {
                    b.classList.add('locked');
                    b.style.cursor = 'default';
                });
                elements.hintButton.disabled = true;
                elements.skipButton.disabled = true;
            } else {
                elements.feedbackLabel.innerText = "Not quite right...";
                elements.feedbackLabel.className = "text-xl font-bold text-amber-500 animate-pop";
            }
        }

        // --- HELPERS ---
        window.giveHint = function() {
            // Find first empty slot
            const emptySlot = state.slots.find(s => !state.slotMap.has(s.dataset.id));
            if (!emptySlot) return;

            const charNeeded = emptySlot.dataset.target;

            // Find a ball with that char that is NOT already in the correct slot
            // Actually, just find one that is free (not in a slot)
            const ball = state.balls.find(b => b.dataset.char === charNeeded && !b.dataset.slotId);

            if (ball) {
                // Manually snap it
                const slotRect = emptySlot.getBoundingClientRect();
                const containerRect = elements.lettersContainer.getBoundingClientRect();
                
                ball.style.left = (slotRect.left - containerRect.left) + "px";
                ball.style.top = (slotRect.top - containerRect.top) + "px";
                
                state.slotMap.set(emptySlot.dataset.id, ball);
                ball.dataset.slotId = emptySlot.dataset.id;
                ball.classList.add('locked'); // Lock hinted balls? Maybe
                
                checkWin();
            }
        };

        window.skipWord = function() {
            elements.feedbackLabel.innerText = `Skipped! Word was ${state.currentWord}`;
            setTimeout(newRound, 1000);
        };

        // Expose functions for buttons
        window.processVocabSource = processVocabSource;
        window.giveHint = window.giveHint;
        window.skipWord = window.skipWord;
        window.newRound = newRound;

    </script>
</body>
</html>